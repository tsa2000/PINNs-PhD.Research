import torch
import torch.nn as nn
import numpy as np
import copy
import matplotlib.pyplot as plt

# 1. ØªØ«Ø¨ÙŠØª Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
torch.manual_seed(42)
np.random.seed(42)

# 2. Ø§Ù„Ø«ÙˆØ§Ø¨Øª
M, CP, A = 0.042, 800.0, 0.004185
T_INF, H_BASELINE = 23.0, 5.0
SIGMA, EPSILON = 5.67e-8, 0.85
TIME_SCALE, T_SCALE, V_SCALE = 60.0, 1000.0, 200.0

# 3. Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©
def get_q_tr(t):
    q_peak = 11040.0
    val = torch.zeros_like(t)
    mask1 = (t < 1.0) & (t >= 0.0)
    val[mask1] = q_peak * t[mask1]
    mask2 = (t >= 1.0) & (t <= 6.0)
    val[mask2] = q_peak * (1.0 - (t[mask2] - 1.0) / 5.0)
    return val

def get_h(v_kmh):
    v_ms = torch.abs(v_kmh) / 3.6
    h_forced = 5.0 + 4.0 * (v_ms ** 0.8)
    return torch.clamp(h_forced, min=H_BASELINE)

# 4. Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø© (Heavy-Duty)
class BatteryPINN_Uncertainty(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            # Ø²Ø¯Ù†Ø§ Ø§Ù„Ø¹Ø±Ø¶ Ø¥Ù„Ù‰ 128 Ù„Ø§Ø³ØªÙŠØ¹Ø§Ø¨ Ø§Ù„Ø¶Ø¬ÙŠØ¬
            nn.Linear(2, 128), nn.Tanh(),
            nn.Dropout(0.05),  # Ù‚Ù„Ù„Ù†Ø§ Ø§Ù„Ù†Ø³Ø¨Ø© Ø¥Ù„Ù‰ 5% ÙÙ‚Ø·
            nn.Linear(128, 128), nn.Tanh(),
            nn.Dropout(0.05),
            nn.Linear(128, 128), nn.Tanh(),
            nn.Linear(128, 1)
        )

    def forward(self, t, v):
        inputs = torch.cat([t/TIME_SCALE, v/V_SCALE], dim=1)
        return self.net(inputs) * T_SCALE

# 5. Ø¯Ø§Ù„Ø© Ø§Ù„Ø®Ø³Ø§Ø±Ø©
def physics_loss(model, t, v):
    t.requires_grad = True
    T_pred = model(t, v)
    dTdt = torch.autograd.grad(T_pred, t, grad_outputs=torch.ones_like(T_pred), create_graph=True)[0]

    Q_gen, h_val = get_q_tr(t), get_h(v)
    Q_conv = h_val * A * (T_pred - T_INF)
    Q_rad = EPSILON * SIGMA * A * ((T_pred+273.15)**4 - (T_INF+273.15)**4)

    residual = (M * CP * dTdt) - (Q_gen - Q_conv - Q_rad)
    return torch.mean((residual / (M*CP))**2)

# 6. Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ù…ÙƒØ«Ù
model = BatteryPINN_Uncertainty()
optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='min', factor=0.5, patience=500)

loss_weight_ic = 100.0
best_loss = float('inf')
best_model_state = None

print("ğŸš€ Starting Heavy-Duty Uncertainty Training...")

for epoch in range(8001): # Ø²Ø¯Ù†Ø§ Ø§Ù„Ø¯ÙˆØ±Ø§Øª Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø¯Ù‚Ø©
    optimizer.zero_grad()

    # ØªØ±ÙƒÙŠØ² Ø´Ø¯ÙŠØ¯ Ø¹Ù„Ù‰ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù†ÙØ¬Ø§Ø± (70% Ù…Ù† Ø§Ù„Ù†Ù‚Ø§Ø·)
    t_event = torch.rand(1400, 1) * 10.0
    v_event = torch.rand(1400, 1) * 200.0

    t_cool = 10.0 + torch.rand(600, 1) * 50.0
    v_cool = torch.rand(600, 1) * 200.0

    t_phy = torch.cat([t_event, t_cool], dim=0)
    v_phy = torch.cat([v_event, v_cool], dim=0)

    loss_phy = physics_loss(model, t_phy, v_phy)

    # IC
    t_ic = torch.zeros(500, 1)
    v_ic = torch.rand(500, 1) * 200.0
    loss_ic = torch.mean((model(t_ic, v_ic) - T_INF)**2)

    total_loss = loss_phy + loss_weight_ic * loss_ic
    total_loss.backward()
    optimizer.step()
    scheduler.step(total_loss)

    if total_loss.item() < best_loss:
        best_loss = total_loss.item()
        best_model_state = copy.deepcopy(model.state_dict())

    if epoch % 1000 == 0:
        print(f"Epoch {epoch}: Loss {total_loss.item():.5f} | Best: {best_loss:.5f}")

print("âœ… Training Complete.")
model.load_state_dict(best_model_state)
torch.save(model.state_dict(), "battery_pinn_uncertainty.pth")

# ==========================================
# Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù„Ù„ØªØ­Ù‚Ù‚ (Auto-Plot)
# ==========================================
def predict_with_uncertainty(model, t, v, n_samples=100):
    model.train()
    preds = []
    with torch.no_grad():
        for _ in range(n_samples):
            preds.append(model(t, v).numpy().flatten())
    preds = np.array(preds)
    return preds.mean(axis=0), preds.std(axis=0)

t_vals = torch.linspace(0, 60, 200).view(-1, 1)
v_vals = torch.zeros_like(t_vals)
mean, std = predict_with_uncertainty(model, t_vals, v_vals)

plt.figure(figsize=(10, 6))
plt.plot(t_vals, mean, 'r-', linewidth=2, label='Mean Prediction')
plt.fill_between(t_vals.flatten(), mean - 2*std, mean + 2*std, color='red', alpha=0.3, label='95% CI')
plt.title(f"Uncertainty Check (Peak: {mean.max():.1f}Â°C)")
plt.xlabel("Time (s)")
plt.ylabel("Temperature (Â°C)")
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
